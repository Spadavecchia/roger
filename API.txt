Roger: multi tenant job processor
- multi-tentancy architecture
- based on Rabbitmq
- per-queue concurrency control
- jobs cancellation
- unique job per execution
- unique job per queue
- pausing / unpausing work queues
nice to have:
- retry w/ exponential backoff
- HTTP management API (phoenix mountable)




application logic callback modules

worker callback
- worker: init
- worker: pre execution (job, state)
- worker: post execution (job, result, state)
- worker: on error (job, exception, state)

consumer callback
- consumer: init
- consumer: worker deliver (state); (return: worker state)

global application state callbacks
- init
- restore (opaque)
- save (opaque)


Job behaviour
- cancel_key(args)
- global_execution_key(args)
- global_queue_key(args)
-> returning nil in any of these means they are not used

- queue_type(args)
- perform(args)




API

Client
- start_link(config)
- open_channel
- publish

Consumer
- start_link(queues, state)
- reconfigure(queues)
- stop



Job
Job.create(module, args)
Job.enqueue!(%Job{}, %Queue{})
